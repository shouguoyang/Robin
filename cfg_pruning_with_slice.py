# -*- coding: utf-8 -*-
"""
-------------------------------------------------
   File Name：     cfg_pruning_with_slice
   Description :   Perform slicing through data flow analysis, and use the function CFG generated by slicing to find a new path;
    Start slicing from the cmp, test, etc., instructions that affect the FLAG register of the last basic block of the patch block, and increase the in-edge weight of the basic block that has data dependencies.
    Make the basic blocks that contain data dependencies as much as possible in the shortest path to be sliced through data flow analysis, and use the function CFG generated by the slice to find a new path;
    Start slicing from the cmp, test, etc., instructions that affect the FLAG register of the last basic block of the patch block, and increase the in-edge weight of the basic block that has data dependencies.
    Make the shortest path contain as much as possible the basic blocks of data dependence
   date：          2021/1/8
-------------------------------------------------
   Change Activity:
                   2021/1/8:
-------------------------------------------------
"""
from binary_slice_code.backward_slice_main import iterate_slice
import os
import pickle
import angr
import networkx as nx
import logging
l = logging.getLogger('slicing')
l.setLevel(logging.DEBUG)
from miasm.analysis import LocationDB,Container,Machine
class CFG_PS():

    def __init__(self, binary_path, angr_function_cfg: nx.DiGraph,
                 function_addr: int, check_addr, patch_addr: int, angr_project:angr.Project):
        '''
        :param binary_path:
        :param angr_function_cfg:
        :param function_addr:
        :param patch_addr:
        '''
        self._bin = binary_path
        self._func_addr = function_addr
        self._TARGET_INSTRUCTION=['CMP','TEST', 'OR', 'XOR']
        self.cfg = angr_function_cfg
        self._angr_proj = angr_project
        self._mdis = self._init_miasm()
        self.asm_cfg = self._mdis.dis_multiblock(self._func_addr)
        self._check_node_addr = check_addr
        self._patch_addr = patch_addr
        self._function_entry_node = self._angr_proj.factory.block(function_addr).codenode
        self._check_node = self._angr_proj.factory.block(check_addr).codenode
        if self._check_node not in angr_function_cfg.nodes:
            for node in angr_function_cfg.nodes:
                if self._check_node.addr > node.addr and node.addr + node.size >= self._check_node.addr:
                    self._check_node = node
                    self._check_node_addr = node.addr
                    break

        self._remove_unreachable_node()

    def do_slicing(self):
        slice_target_addrs = []
        patch_addr = self._patch_addr
        check_addr = self._check_node_addr
        angr_function_cfg = self.cfg
        if patch_addr is not None and check_addr is not None:
            addr = self._get_FLAG_instruction(check_addr)
            slice_target_addrs.append(addr)
        else:

            pre_nodes = angr_function_cfg.predecessors(self._check_node)
            for node in pre_nodes:
                addr = self._get_FLAG_instruction(node.addr)
                slice_target_addrs.append(addr)
        self._slice_target_addrs = slice_target_addrs
        if len(slice_target_addrs) == 0:
            raise Exception("target address is empty for slicing")
        blocks_data_depend = iterate_slice(self._bin, self._func_addr, self._slice_target_addrs, self.asm_cfg)
        self._re_write_edge_weight(blocks_data_depend)

    def _remove_unreachable_node(self):
        l.debug("[*] getting all unreacheable_nodes")
        unreacheable_nodes = list(self._get_all_unreacheable_blocks(self._check_node_addr))
        to_remove_edges = []
        for node in unreacheable_nodes:
            for node_child in self.cfg[node]:
                to_remove_edges.append((node, node_child))
        for node, node_child in to_remove_edges:
            self.cfg.remove_edge(node, node_child)


    def _init_miasm(self):
        fdesc = open(self._bin, 'rb')
        loc_db = LocationDB()
        cont = Container.from_stream(fdesc, loc_db)
        machine = Machine(cont.arch)
        mdis = machine.dis_engine(cont.bin_stream, loc_db=cont.loc_db)
        return mdis

    def _re_write_edge_weight(self, blocks_to_add_weight, weight_increament=1000):
        '''
        :param self.cfg:
        :param blocks_to_add_weight:
        :return:
        '''
        for node_addr in blocks_to_add_weight:
            block = self._angr_proj.factory.block(node_addr)
            node_in_graph = block.codenode
            l.debug('[*] add weigth to edges to node {}'.format(hex(node_addr)))
            for pred_node in list(self.cfg.predecessors(node_in_graph)):
                self.cfg[pred_node][node_in_graph].update({'weight': weight_increament})
        return self.cfg

    def get_pruned_cfg(self):
        return self.cfg

    def get_shortest_paths(self):
        # return nx.dijkstra_path(self.cfg, source=self._function_entry_node, target=self._check_node)
        return nx.all_shortest_paths(self.cfg, source=self._function_entry_node, target=self._check_node, weight='weight')

    def get_simple_paths(self, cutoff=None):

        return nx.all_simple_paths(self.cfg, source=self._function_entry_node, target=self._check_node, cutoff=cutoff)

    def _get_all_unreacheable_blocks(self, check_node_addr):
        '''

        '''
        cfg = self.cfg
        check_node = self._check_node
        if check_node not in cfg.nodes:
            raise Exception("check node in not in cfg.nodes")

        reacheable_blocks = []  # 记录可以到达补丁块的其他基本块的地址
        predecessor_queue = [check_node]
        while len(predecessor_queue) > 0:
            current_node = predecessor_queue.pop(0)

            for parentnode in cfg.predecessors(current_node):
                if parentnode.addr not in reacheable_blocks:
                    reacheable_blocks.append(parentnode.addr)
                    predecessor_queue.append(parentnode)

        for node in cfg.nodes:
            if node.addr not in reacheable_blocks:
                yield node

    def _get_FLAG_instruction(self, node_addr:int):
        '''
        :param node:
        '''
        block = self._mdis.dis_block(node_addr)
        if block.lines[-1].name == 'CALL':
            try:
                next_loc_key = block.get_next()
                next_block_addr = self._mdis.loc_db.get_location_offset(next_loc_key)
                return self._get_FLAG_instruction(next_block_addr)
            except KeyError as e:
                l.error("[-] block {} has no successor".format(hex(node_addr)))
                return node_addr

        for inst in reversed(block.lines):
            if inst.name in self._TARGET_INSTRUCTION:
                return inst.offset
        else:
            return node_addr


def itest_cfgps():
    '''
      Run for CVE-2018-20671,/home/angr/PatchDiff/binaries/binutils/O0/objdump-2.31.1,/home/angr/PatchDiff/binaries/binutils/O0/objdump-2.32,load_specific_debug_section
      0x804f309 0x804f34b
     '''
    x='CVE-2018-7568,/home/angr/PatchDiff/binaries/binutils/O0/addr2line-2.30,/home/angr/PatchDiff/binaries/binutils/O0/addr2line-2.31,parse_die'
    check_addr = 0x80b421f
    patch_addr = 0x80b4250


    s = x.split(',')
    binary_path =s[2]
    function_name = s[-1]
    p = angr.Project(binary_path,
                     load_options={'auto_load_libs': False})

    func_addr = p.loader.find_symbol(function_name).rebased_addr

    cfgcache = binary_path+".angr_cfg"
    if os.path.exists(cfgcache):
        cfg = pickle.load(open(cfgcache, 'rb'))
    else:
        cfg = p.analyses.CFGFast()
    function_cfg = cfg.functions[function_name].graph

    cfgps = CFG_PS(binary_path, function_cfg, func_addr, check_addr, patch_addr, p)
    for path in cfgps.get_shortest_paths():
        addrs = [hex(node.addr) for node in path]
        print("[>] path: {}".format(",".join(addrs)))


if __name__ == '__main__':
    itest_cfgps()